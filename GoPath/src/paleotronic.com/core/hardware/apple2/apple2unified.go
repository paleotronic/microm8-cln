package apple2

import "paleotronic.com/octalyzer/video/font"

var DHGRBytePatterns = [16][4]int{
	[4]int{0x00, 0x00, 0x00, 0x00}, // Black				lores(0)
	[4]int{0x08, 0x11, 0x22, 0x44}, // Magenta
	[4]int{0x44, 0x08, 0x11, 0x22}, // Brown
	[4]int{0x4c, 0x19, 0x33, 0x66}, // Orange
	[4]int{0x22, 0x44, 0x08, 0x11}, // Dark Green
	[4]int{0x2a, 0x55, 0x2a, 0x55}, // Grey 1
	[4]int{0x66, 0x4c, 0x19, 0x33}, // Green
	[4]int{0x6E, 0x5D, 0x3B, 0x77}, // Yellow
	[4]int{0x11, 0x22, 0x44, 0x08}, // Dark blue
	[4]int{0x19, 0x33, 0x66, 0x4C}, // Violet
	[4]int{0x55, 0x2A, 0x55, 0x2A}, // Grey 2
	[4]int{0x5D, 0x3B, 0x77, 0x6E}, // Pink
	[4]int{0x33, 0x66, 0x4C, 0x19}, // Medium Blue
	[4]int{0x3B, 0x77, 0x6E, 0x5D}, // Light Blue
	[4]int{0x77, 0x6E, 0x5D, 0x3B}, // Aqua
	[4]int{0x7F, 0x7F, 0x7F, 0x7F}, // White				lores(15)
}

var DHGRPaletteToLores = map[int]int{
	0x0: 0x0,
	0x1: 0x1,
	0x8: 0x2,
	0x9: 0x3,
	0x4: 0x4,
	0x5: 0x5,
	0xc: 0x6,
	0xd: 0x7,
	0x2: 0x8,
	0x3: 0x9,
	0xa: 0xa,
	0xb: 0xb,
	0x6: 0xc,
	0x7: 0xd,
	0xe: 0xe,
	0xf: 0xf,
}

const DHR_WHITE = 15
const DHR_BLACK = 0

var DHGRColorTable [16][16][16]uint16

var a2DHGRFrom = [16][16]uint16{
	{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
	{0x0000, 0x1110, 0x0000, 0x1110, 0x0000, 0x1110, 0x0000, 0x1110, 0x0000, 0x1110, 0x0000, 0x1110, 0x0000, 0x1110, 0x0000, 0x1110},
	{0x0000, 0x3300, 0x2200, 0x3300, 0x0000, 0x3300, 0x2200, 0x3300, 0x0000, 0x3300, 0x2200, 0x3300, 0x0000, 0x3300, 0x2200, 0x3300},
	{0x0000, 0x3300, 0x2200, 0x3300, 0x0000, 0x3300, 0x2200, 0x3300, 0x0000, 0x3300, 0x2200, 0x3300, 0x0000, 0x3300, 0x2200, 0x3300},
	{0x0400, 0x5500, 0x6400, 0x7500, 0x4400, 0x5500, 0x6400, 0x7500, 0x0400, 0x5500, 0x6400, 0x7500, 0x4400, 0x5500, 0x6400, 0x7500},
	{0x0500, 0x5500, 0x6500, 0x7500, 0x4500, 0x5500, 0x6500, 0x7500, 0x0500, 0x5500, 0x6500, 0x7500, 0x4500, 0x5500, 0x6500, 0x7500},
	{0x0600, 0x7700, 0x6600, 0x7700, 0x4600, 0x7700, 0x6600, 0x7700, 0x0600, 0x7700, 0x6600, 0x7700, 0x4600, 0x7700, 0x6600, 0x7700},
	{0x0700, 0x7700, 0x6700, 0x7700, 0x4700, 0x7700, 0x6700, 0x7700, 0x0700, 0x7700, 0x6700, 0x7700, 0x4700, 0x7700, 0x6700, 0x7700},
	{0x8000, 0x9000, 0xA000, 0xB000, 0x8000, 0x9000, 0xA000, 0xB000, 0x8000, 0x9000, 0xA000, 0xB000, 0x8000, 0x9000, 0xA000, 0xB000},
	{0x8990, 0x9990, 0xA990, 0xB990, 0x8990, 0x9990, 0xA990, 0xB990, 0x8990, 0x9990, 0xA990, 0xB990, 0x8990, 0x9990, 0xA990, 0xB990},
	{0xAAA0, 0xBBA0, 0xAAA0, 0xBBA0, 0xAAA0, 0xBBA0, 0xAAA0, 0xBBA0, 0xAAA0, 0xBBA0, 0xAAA0, 0xBBA0, 0xAAA0, 0xBBA0, 0xAAA0, 0xBBA0},
	{0xABB0, 0xBBB0, 0xABB0, 0xBBB0, 0xABB0, 0xBBB0, 0xABB0, 0xBBB0, 0xABB0, 0xBBB0, 0xABB0, 0xBBB0, 0xABB0, 0xBBB0, 0xABB0, 0xBBB0},
	{0xCC00, 0xDD00, 0xEC00, 0xFD00, 0xCC00, 0xDD00, 0xEC00, 0xFD00, 0xCC00, 0xDD00, 0xEC00, 0xFD00, 0xCC00, 0xDD00, 0xEC00, 0xFD00},
	{0xCDD0, 0xDDD0, 0xEDD0, 0xFDD0, 0xCDD0, 0xDDD0, 0xEDD0, 0xFDD0, 0xCDD0, 0xDDD0, 0xEDD0, 0xFDD0, 0xCDD0, 0xDDD0, 0xEDD0, 0xFDD0},
	{0xEEE0, 0xFFE0, 0xEEE0, 0xFFE0, 0xEEE0, 0xFFE0, 0xEEE0, 0xFFE0, 0xEEE0, 0xFFE0, 0xEEE0, 0xFFE0, 0xEEE0, 0xFFE0, 0xEEE0, 0xFFE0},
	{0xEFF0, 0xFFF0, 0xEFF0, 0xFFF0, 0xEFF0, 0xFFF0, 0xEFF0, 0xFFF0, 0xEFF0, 0xFFF0, 0xEFF0, 0xFFF0, 0xEFF0, 0xFFF0, 0xEFF0, 0xFFF0},
}

var a2DHGRTo = [16][16]uint16{
	{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
	{0x0001, 0x0001, 0x0001, 0x0001, 0x0005, 0x0005, 0x0005, 0x0005, 0x0009, 0x0009, 0x0009, 0x0009, 0x000D, 0x000D, 0x000D, 0x000D},
	{0x0020, 0x0020, 0x0022, 0x0022, 0x0026, 0x0026, 0x0026, 0x0026, 0x00AA, 0x00AA, 0x00AA, 0x00AA, 0x00AE, 0x00AE, 0x00AE, 0x00AE},
	{0x0033, 0x0033, 0x0033, 0x0033, 0x0037, 0x0037, 0x0037, 0x0037, 0x00BB, 0x00BB, 0x00BB, 0x00BB, 0x00BF, 0x00BF, 0x00BF, 0x00BF},
	{0x0000, 0x0000, 0x0000, 0x0000, 0x0044, 0x0044, 0x0044, 0x0044, 0x00CC, 0x00CC, 0x00CC, 0x00CC, 0x00CC, 0x00CC, 0x00CC, 0x00CC},
	{0x0055, 0x0055, 0x0055, 0x0055, 0x0055, 0x0055, 0x0055, 0x0055, 0x00DD, 0x00DD, 0x00DD, 0x00DD, 0x00DD, 0x00DD, 0x00DD, 0x00DD},
	{0x0060, 0x0060, 0x0062, 0x0062, 0x0066, 0x0066, 0x0066, 0x0066, 0x00EE, 0x00EE, 0x00EE, 0x00EE, 0x00EE, 0x00EE, 0x00EE, 0x00EE},
	{0x0077, 0x0077, 0x0077, 0x0077, 0x0077, 0x0077, 0x0077, 0x0077, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF, 0x00FF},
	{0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0888, 0x0888, 0x0888, 0x0888, 0x0888, 0x0888, 0x0888, 0x0888},
	{0x0001, 0x0001, 0x0001, 0x0001, 0x0005, 0x0005, 0x0005, 0x0005, 0x0009, 0x0009, 0x0009, 0x0009, 0x000D, 0x000D, 0x000D, 0x000D},
	{0x0000, 0x0000, 0x0002, 0x0002, 0x0006, 0x0006, 0x0006, 0x0006, 0x000A, 0x000A, 0x000A, 0x000A, 0x000E, 0x000E, 0x000E, 0x000E},
	{0x0003, 0x0003, 0x0003, 0x0003, 0x0007, 0x0007, 0x0007, 0x0007, 0x000B, 0x000B, 0x000B, 0x000B, 0x000F, 0x000F, 0x000F, 0x000F},
	{0x0000, 0x0000, 0x0000, 0x0000, 0x0044, 0x0044, 0x0044, 0x0044, 0x00CC, 0x00CC, 0x00CC, 0x00CC, 0x00CC, 0x00CC, 0x00CC, 0x00CC},
	{0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 0x000D, 0x000D, 0x000D, 0x000D, 0x000D, 0x000D, 0x000D, 0x000D},
	{0x0000, 0x0000, 0x0002, 0x0002, 0x0006, 0x0006, 0x0006, 0x0006, 0x000E, 0x000E, 0x000E, 0x000E, 0x000E, 0x000E, 0x000E, 0x000E},
	{0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x0007, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F, 0x000F},
}

var (
	fontOSD     *font.DecalFont
	fontsLoaded bool
	SnapShot    bool
	SnapCount   int
)

var a2font *font.DecalFont

func InitFonts() {
	if fontsLoaded {
		return
	}
	f, err := font.LoadFromFile("fonts/appleiifont.yaml")
	if err != nil {
		panic(err)
	}
	a2font = f
	// for i, _ := range settings.DefaultFont {
	// 	//settings.DefaultFont[i] = font
	// }
	fontsLoaded = true
}

func init() {
	for iFrom := 0; iFrom < 16; iFrom++ {
		for iCurrent := 0; iCurrent < 16; iCurrent++ {
			for iTo := 0; iTo < 16; iTo++ {
				DHGRColorTable[iFrom][iCurrent][iTo] = a2DHGRFrom[iCurrent][iFrom] | a2DHGRTo[iCurrent][iTo]
			}
		}
	}
	InitFonts()
}

var FontCacheNormal [1]map[rune][]byte
var FontCacheInverted [1]map[rune][]byte

// GetDefaultFont retrives the current Apple II system font as rom compatible bitplanes
func GetDefaultFont(slot int) (map[rune][]byte, map[rune][]byte) {
	if FontCacheNormal[slot] == nil {
		f := a2font
		FontCacheNormal[slot], FontCacheInverted[slot] = f.GetFontBitplanes()
	}
	return FontCacheNormal[slot], FontCacheInverted[slot]
}

// ColorsForScanLineDHGR converts a bitplane into color values
func ColorsForScanLineDHGR(b []byte, mono bool) []int {

	// log2.Printf("cfs got %d bytes", len(b))

	// portion := int(560 * (float64(len(b)) / 80))

	line := make([]int, 560)

	var rbval int

	var monobits bool

	bitcols := []int{DHR_BLACK, DHR_WHITE}

	var useColor = make([]bool, len(b))
	var mixed = false

	for i, v := range b {
		useColor[i] = (v & 0x80) != 0
	}

	var bitpatterns [140]int
	var bitmono [140]bool
	var bitindex int

	for j, abyte := range b {
		monobits = mono || (mixed && !useColor[j])
		for k := 0; k < 7; k++ {
			x := j*7 + k
			abit := int(abyte & 0x01)
			rbval = ((rbval << 1) & 0xf) | abit
			abyte = abyte >> 1
			if x%4 == 3 {
				bitpatterns[bitindex] = rbval
				bitmono[bitindex] = monobits
				bitindex++
			}
		}
	}

	var prev, next int
	for i, current := range bitpatterns {
		x := 4 * i
		if bitmono[i] {
			for xx := 3; xx >= 0; xx-- {
				line[x+xx] = bitcols[current&1]
				current >>= 1
			}
		} else {
			if i < len(bitpatterns)-1 {
				next = bitpatterns[i+1]
			} else {
				next = 0
			}
			if i > 0 {
				prev = bitpatterns[i-1]
			} else {
				prev = 0
			}
			bp := DHGRColorTable[prev][current][next]
			line[x+0] = DHGRPaletteToLores[int(bp>>12)&0xf]
			line[x+1] = DHGRPaletteToLores[int(bp>>8)&0xf]
			line[x+2] = DHGRPaletteToLores[int(bp>>4)&0xf]
			line[x+3] = DHGRPaletteToLores[int(bp)&0xf]
		}
	}

	return line

}

var HGRToDHGR [512][256]uint64
var HGRToDHGRMono [256][256]uint64

func byteDoubler(b int) int {
	num := ((b & 0x040) << 6) |
		((b & 0x020) << 5) |
		((b & 0x010) << 4) |
		((b & 0x08) << 3) |
		((b & 0x04) << 2) |
		((b & 0x02) << 1) |
		(b & 0x01)
	return num | (num << 1)
}

func init() {

	var b1, b2 int
	for bb1 := 0; bb1 < 512; bb1++ {
		for bb2 := 0; bb2 < 256; bb2++ {
			var value int
			if (bb1 & 0x0181) >= 0x0101 {
				value = 1
			}
			b1 = byteDoubler((bb1 & 0x07f))
			if (bb1 & 0x080) != 0 {
				b1 <<= 1
			}
			b2 = byteDoubler((bb2 & 0x07f))
			if (bb2 & 0x080) != 0 {
				b2 <<= 1
			}
			if (bb1&0x040) == 0x040 && (bb2&1) != 0 {
				b2 |= 1
			}
			value |= b1 | (b2 << 14)
			if (bb2 & 0x040) != 0 {
				value |= 0x10000000
			}
			HGRToDHGR[bb1][bb2] = uint64(value)
			mvalue := byteDoubler(bb1) | (byteDoubler(bb2) << 14)
			HGRToDHGRMono[bb1&0x0ff][bb2] = uint64(mvalue)
		}
	}

}

func ConvertHGRToDHGRPattern(b []byte, mono bool) []byte {
	// log2.Printf("convHGRToDHGR: %d bytes received", len(b))
	// input is 40 bytes of data
	out := make([]byte, len(b)*2)
	if len(b) == 0 {
		return out
	}
	var b1, b2 int
	var extraHalfBit = false
	var idx int
	var dhgrWord uint64
	for i := 0; i < len(b); i += 2 {
		b1 = int(b[i+0])
		if i+1 < len(b) {
			b2 = int(b[i+1])
		} else {
			b2 = 0
		}
		if extraHalfBit && i > 0 {
			idx = b1 | 0x0100
		} else {
			idx = b1
		}
		if mono {
			dhgrWord = HGRToDHGRMono[b1][b2]
		} else {
			dhgrWord = HGRToDHGR[idx][b2]
		}
		extraHalfBit = (dhgrWord & 0x10000000) != 0
		out[i*2+0] = byte(dhgrWord & 0x7f)
		out[i*2+1] = byte((dhgrWord >> 7) & 0x7f)
		if i+1 < len(b) {
			out[i*2+2] = byte((dhgrWord >> 14) & 0x7f)
			out[i*2+3] = byte((dhgrWord >> 21) & 0x7f)
		}
	}

	return out
}

func HalfBitShift(b []uint64) []uint64 {
	var fbp uint64
	var out = make([]uint64, len(b))
	for i, v := range b {
		//v := b[i]
		out[i] = ((v << 1) & 0x7f) | fbp
		fbp = (v & 64) >> 6
	}
	return out
}

// var DHGRPaletteToLores = map[int]int{
// 	0x0: 0x0,
// 	0x1: 0x1,
// 	0x8: 0x2,
// 	0x9: 0x3,
// 	0x4: 0x4,
// 	0x5: 0x5,
// 	0xc: 0x6,
// 	0xd: 0x7,
// 	0x2: 0x8,
// 	0x3: 0x9,
// 	0xa: 0xa,
// 	0xb: 0xb,
// 	0x6: 0xc,
// 	0x7: 0xd,
// 	0xe: 0xe,
// 	0xf: 0xf,
// }

func ror4bit(c int) int {
	return (c >> 1) | ((c & 1) << 3)
}

func rol4bit(c int) int {
	return ((c << 1) | ((c & 8) >> 3)) & 0xf
}

func ColorFlip(b []int) []int {
	out := make([]int, len(b))
	for i, v := range b {
		out[i] = rol4bit(v)
		out[i] = ((out[i] << 2) & 0xf) | ((out[i] >> 2) & 0xf)
	}
	return out
}

func ColorFlipB(b []byte) []byte {
	out := make([]byte, len(b))
	for i, v := range b {
		out[i] = byte(rol4bit(int(v)))
		out[i] = ((out[i] << 2) & 0xf) | ((out[i] >> 2) & 0xf)
	}
	return out
}
